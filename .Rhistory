, N = sum(n.N, n.S)
)
)
}
nrow(dat6)
#remove rows where hedges g' wasn't calculate == NA
dat7 <- drop_na(dat6,hsg)
nrow(dat7)
library(lme4)
dat7 <- transform(dat7, Class = factor(Class, levels = c("Aves", "Actinopterygii",
"Amphibia", "Arachnida" ,
"Insecta", "Malacostraca",
"Mammalia","Reptilia" )))
dat7 <- transform(dat7,Response = factor(Response, levels = c(
"Lat", "Agg", "Dur", "Rate"
)) )
levels(dat7$Breeding)
dat <- read.csv("MetaDatRev_ToFinish.csv")
source("HedgesGFunction.R")
#remove unnecesary columns so it is easier to look at
dat1 <- dat %>%
select(-c(X,Name,Dur.Cat,Rate.Cat,Author1,Author2,
Author3,Author4,Author5,Notes,Meta.scientist,Years,Genus,Species,
Latency,Duration,Rate,Aggression))
#dataframe where the values of all means, standard deviations
#and number of individuals are made into one column (value)
#and id (which one and what type of response is another column)- variable
dat2 <- melt(dat1, c(
"Study"          ,"Family"         ,"Order"          ,"Class"          , "Binomial",
"Location" ,      "Breeding"       ,"Territory.type" ,"Sex"            ,"Method",
"Stimulus" ,     "Expt.Type"      ,"Lat.Cat"        ,"Agg.Meth"       ,"Variation"
, "Lat.site", "Dur.site", "Rate.site", "Agg.site"
))
# create two new columns "Response" and "Stat.Type"
dat3 <- transform(dat2, Response = numeric(nrow(dat2)), Stat.Type = numeric(nrow(dat2)))
#fill in new columns by spliting the names in the previous variable column (Response = type of response)
# and take the type of statistic (mean/standard deviation) or number of indivuals into the other column(Stat.Type)
for(i in 1:nrow(dat3)) {
temp_str <- unlist(strsplit(as.character(dat3$variable[i]), split = "[.]"))
dat3[i, ] <- transform(dat3[i, ]
, Response  = temp_str[1]
, Stat.Type = paste(temp_str[2:length(temp_str)], collapse = "."))
}
#remove rows that don't have any values
dat3 <- dat3[!is.na(dat3$value), ]
#remove extra column and spread out the Stat.Type so that mean/sd/n individuals has their own columns
dat4 <- dat3 %>%
select(-variable) %>%
spread(Stat.Type, value)
dat5 <- melt(dat4, c("Study"          ,"Family"         ,"Order"          ,"Class"    , "Binomial"      ,"Location" ,
"Breeding"       ,"Territory.type" ,"Sex"            ,"Method"         ,"Stimulus" ,
"Expt.Type"      ,"Lat.Cat"        ,"Agg.Meth"       ,"Variation",
"Response", "N","n.N","n.S","N.SD","S","S.SD"))
## remove empty sites
dat5 <- transform(dat5, Response.Type = numeric(nrow(dat5)), Site.Type = numeric(nrow(dat5)))
## split the Type.Site into two columns and keep only...
for(i in 1:nrow(dat5)) {
temp_str <- unlist(strsplit(as.character(dat5$variable[i]), split = "[.]"))
dat5[i, ] <- transform(dat5[i, ]
, Response.Type  = temp_str[1]
, Site.Type = paste(temp_str[2:length(temp_str)], collapse = "."))
}
## ... where types match
dat6 <- dat5 %>% filter(Response == Response.Type)
colnames(dat6)[which(colnames(dat6)=="value")] <- "site"
## remove Response.Type and Site.Type columns
dat6 <- dat6 %>% select(-Response.Type, -Site.Type)
#create column for hedges g'
dat6 <- transform(dat6, hsg = 0)
# calculate hedges g for each row
for(i in 1:nrow(dat6)) {
dat6[i, ]$hsg <- with(dat6[i, ],
hedgesg(  m1   = N
, m2  = S
, SDp = SDp(
n1  = n.N
,n2  = n.S
,SD1 = N.SD
,SD2 = S.SD)
, N = sum(n.N, n.S)
)
)
}
#remove rows where hedges g' wasn't calculate == NA
dat7 <- drop_na(dat6,hsg)
dat7 <- transform(dat7, Class = factor(Class, levels = c("Aves", "Actinopterygii",
"Amphibia", "Arachnida" ,
"Insecta", "Malacostraca",
"Mammalia","Reptilia" )))
dat7 <- transform(dat7,Response = factor(Response, levels = c(
"Lat", "Agg", "Dur", "Rate"
)) )
levels(dat7$Breeding)
dat8 <- dat7 %>% filter(Breeding != "")
levels(dat8$Breeding)
nrow(dat8)
nrow(dat7)
unique(dat7$Study)
unique(dat8$Study)
dat8 <- dat7[dat7$Breeding != "", ]
levels(dat8$Breeding)
nrow(dat8)
nrow(unique(dat8$Study))
count(unique(dat8$Study))
(unique(dat8$Study))
dat8 <- dat7 %>% filter(Breeding != "")
mod <- lmer(hsg ~ Class+Breeding+Sex+Territory.type+Response+(1|Study),data=dat7)
plot(resid(mod))
qqnorm(resid(mod))
qqline(resid(mod))
coefplot(mod)
?droplevels
mod <- lmer(hsg ~ Class+Breeding+Sex+Territory.type+Response+(1|Study),data=dat8)
plot(resid(mod))
qqnorm(resid(mod))
qqline(resid(mod))
coefplot(mod)
str(dat8)
for(i in 1:nrow(dat8)){
if (dat8$Response[i] == "Lat") {
dat8$hsg[i] <- -dat8$hsg[i]
}
}
mod <- lmer(hsg ~ Class+Breeding+Sex+Territory.type+Response+(1|Study),data=dat8)
plot(resid(mod))
qqnorm(resid(mod))
qqline(resid(mod))
coefplot(mod)
library(lmerTest)
summary(mod)
summary(mod)
anova(mod)
str(dat8)
min(dat8$n.N)
min(dat8$n.S)
str(dat7)
dat_site <- dat7 %>% filter(!is.na(site))
str(dat_site)
nrow(dat_site)
nrow(dat7)
mod_site <- lmer(hsg~site + (1|Study), data = dat_site)
coef_plot(mod_site)
coefplot(mod_site)
levels(dat_site$site)
levels(as.factor(dat_site$site))
dat_site <- dat7 %>% filter(!is.na(site)) %>% filter(site != "")
mod_site <- lmer(hsg~site + (1|Study), data = dat_site)
coefplot(mod_site)
nrow(dat_site)
nrow(dat7)
250-188
unique(dat_site$Study)
dat9<-droplevels(dat_site)
nrow(dat9)
unique(dat9$Study)
unique(dat7$Study)
119-80
dat10 <- droplevels(dat8)
unique(dat10$Study)
119-109
plot(resid(mod_site))
qqplot(resid(mod_site))
qqnorm(resid(mod_site))
qqline(resid(mod_site))
setwd("C:/Users/jower/Downloads")
## read in data
nest <- read.csv("nestdat.csv")
## load required libraries, if you don't have these install them first
library(vegan)
library(tidyverse)
# make subset dataframe for invasive only and native only, remove rows (sites that had 0)
invasive <- nest %>%
select(Site, Year,INV1,INV2,INV3,INV4,INV5,INV6,INV7,INV8,INV9)
native <- nest %>%
select(-c(INV1,INV2,INV3,INV4,INV5,INV6,INV7,INV8,INV9,UrbanPer,Distance,Area))
nest_comm <- nest %>%
select(-c(Site,Year, UrbanPer, Distance,Area))
## run pcoa with all data
# first you need a distance matrix - using jaccard dissimilarity bc it is presence/absence
all_dist <- vegdist(nest_comm, method = "jaccard", binary = T)
all_pcoa <- cmdscale(all_dist, k=3)
invasive1 <- invasive[rowSums(invasive[,-c(1:2)]) != 0, ]
# now remove rows that aren't part of the community matrix
inv_comm <- invasive1 %>% select(-c(Site,Year))
# run distance matrix
inv_dist <- vegdist(inv_comm, method = "jaccard", binary = T)
# run pcoa
inv_pcoa <- cmdscale(inv_dist, k=3)
## native species
# remove rows (sites/year) that don't have any individuals
native1 <- native[rowSums(native[,-c(1:2)]) !=0, ]
# make community matrix
nat_comm <- native1 %>% select(-c(Site, Year))
# run distance matrix
nat_dist <- vegdist(nat_comm, method = "jaccard", binary = T)
# run pcoa
nat_pcoa <- cmdscale(nat_dist, k=3)
## graphing set up - just for beauty
theme_set(theme_bw())
theme_update(axis.text.x = element_text(size = 12),
axis.text.y = element_text(size = 12),
axis.title.x = element_text(size = 14),
axis.title.y = element_text(size = 14),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
legend.spacing = unit(0.25, "cm"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background = element_blank(),
panel.spacing = unit(0, "lines"),
legend.key = element_rect(fill = "white"),
panel.spacing.y = unit(-0.25, "lines"),
panel.border = element_rect(colour = "black",
fill = NA, size = 1),
strip.text.x = element_text(size = 18, colour = "black",
face = "bold"))
all_graph_data <- data.frame(
Site = nest$Site,
Year = nest$Year,
Points1 = all_pcoa[,1],
Points2 = all_pcoa[,2]
)
all_graph_data_sum <- all_graph_data %>%
group_by(Year) %>%
summarize(Axis1 = mean(Points1), Axis1_sd = sd(Points1),
Axis2 = mean(Points2), Axis2_sd = sd(Points2))
(all_graph <- ggplot(all_graph_data_sum, aes(Axis1, Axis2)) + geom_point(aes(color=Site), size = 3 )+
geom_errorbar(aes(ymax= Axis2+ Axis2_sd, ymin= Axis2- Axis2_sd)) +
geom_errorbarh(aes(xmax=Axis1+Axis1_sd, xmin=Axis1-Axis1_sd))+ggtitle("Full Community"))
(all_graph <- ggplot(all_graph_data_sum, aes(Axis1, Axis2)) + geom_point(aes(color=Year), size = 3 )+
geom_errorbar(aes(ymax= Axis2+ Axis2_sd, ymin= Axis2- Axis2_sd)) +
geom_errorbarh(aes(xmax=Axis1+Axis1_sd, xmin=Axis1-Axis1_sd))+ggtitle("Full Community"))
str(nest)
nest$Site
nest <- nest %>% separate(Site, c("River", "Number"))
str(nest)
# make subset dataframe for invasive only and native only, remove rows (sites that had 0)
invasive <- nest %>%
select(Number,River, Year,INV1,INV2,INV3,INV4,INV5,INV6,INV7,INV8,INV9)
native <- nest %>%
select(-c(INV1,INV2,INV3,INV4,INV5,INV6,INV7,INV8,INV9,UrbanPer,Distance,Area))
nest_comm <- nest %>%
select(-c(Site,Year,River,Number, UrbanPer, Distance,Area))
nest_comm <- nest %>%
select(-c(Year,River,Number, UrbanPer, Distance,Area))
## run pcoa with all data
# first you need a distance matrix - using jaccard dissimilarity bc it is presence/absence
all_dist <- vegdist(nest_comm, method = "jaccard", binary = T)
all_pcoa <- cmdscale(all_dist, k=3)
invasive1 <- invasive[rowSums(invasive[,-c(1:2)]) != 0, ]
str(invasive)
invasive1 <- invasive[rowSums(invasive[,-c(1:3)]) != 0, ]
# now remove rows that aren't part of the community matrix
inv_comm <- invasive1 %>% select(-c(River,Year, Number))
# run distance matrix
inv_dist <- vegdist(inv_comm, method = "jaccard", binary = T)
# run pcoa
inv_pcoa <- cmdscale(inv_dist, k=3)
str(native)
## native species
# remove rows (sites/year) that don't have any individuals
native1 <- native[rowSums(native[,-c(1:3)]) !=0, ]
# make community matrix
nat_comm <- native1 %>% select(-c(River, Year, Number))
# run distance matrix
nat_dist <- vegdist(nat_comm, method = "jaccard", binary = T)
# run pcoa
nat_pcoa <- cmdscale(nat_dist, k=3)
## graphing set up - just for beauty
theme_set(theme_bw())
theme_update(axis.text.x = element_text(size = 12),
axis.text.y = element_text(size = 12),
axis.title.x = element_text(size = 14),
axis.title.y = element_text(size = 14),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
legend.spacing = unit(0.25, "cm"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background = element_blank(),
panel.spacing = unit(0, "lines"),
legend.key = element_rect(fill = "white"),
panel.spacing.y = unit(-0.25, "lines"),
panel.border = element_rect(colour = "black",
fill = NA, size = 1),
strip.text.x = element_text(size = 18, colour = "black",
face = "bold"))
all_graph_data <- data.frame(
River = nest$River,
Year = nest$Year,
Points1 = all_pcoa[,1],
Points2 = all_pcoa[,2]
)
all_graph_data_sum <- all_graph_data %>%
group_by(Year,River) %>%
summarize(Axis1 = mean(Points1), Axis1_sd = sd(Points1),
Axis2 = mean(Points2), Axis2_sd = sd(Points2))
(all_graph <- ggplot(all_graph_data_sum, aes(Axis1, Axis2)) + geom_point(aes(color=Year, shape= River), size = 3 )+
geom_errorbar(aes(ymax= Axis2+ Axis2_sd, ymin= Axis2- Axis2_sd)) +
geom_errorbarh(aes(xmax=Axis1+Axis1_sd, xmin=Axis1-Axis1_sd))+ggtitle("Full Community"))
(all_graph <- ggplot(all_graph_data_sum, aes(Axis1, Axis2)) + geom_point(aes(color=Year, shape= River), size = 3 )+
geom_errorbar(aes(ymax= Axis2+ Axis2_sd, ymin= Axis2- Axis2_sd)) +
geom_errorbarh(aes(xmax=Axis1+Axis1_sd, xmin=Axis1-Axis1_sd))+ggtitle("Full Community")) + facet_wrap(~River)
inv_graph_data <- data.frame(
River = invasive1$River,
Year = invasive1$Year,
Points1 = inv_pcoa[,1],
Points2 = inv_pcoa[,2]
)
inv_graph_sum <- inv_graph_data %>%
group_by(Year, River) %>%
summarise(Axis1 = mean(Points1), Axis1_sd = sd(Points1),
Axis2 = mean(Points2), Axis2_sd = sd(Points2))
## 1 row removed without data- which i assume means a site only occurred in 1 year with invasives so it doesn't have SD
(inv_graph <- ggplot(inv_graph_sum, aes(Axis1, Axis2)) + geom_point(aes(color=Year, shape=River), size = 3 )+
geom_errorbar(aes(ymax= Axis2+ Axis2_sd, ymin= Axis2- Axis2_sd)) +
geom_errorbarh(aes(xmax=Axis1+Axis1_sd, xmin=Axis1-Axis1_sd))+ggtitle("Invasive Species")) + facet_wrap(~River)
nat_graph_data <- data.frame(
River = native1$River,
Year = native$Year,
Points1 = nat_pcoa[,1],
Points2 = nat_pcoa[,2]
)
nat_graph_sum <- nat_graph_data %>%
group_by(Year,River) %>%
summarise(Axis1 = mean(Points1), Axis1_sd = sd(Points1),
Axis2 = mean(Points2), Axis2_sd = sd(Points2))
(nat_graph <- ggplot(nat_graph_sum, aes(Axis1, Axis2)) + geom_point(aes(color=Year, shape = River), size = 3 )+
geom_errorbar(aes(ymax= Axis2+ Axis2_sd, ymin= Axis2- Axis2_sd)) +
geom_errorbarh(aes(xmax=Axis1+Axis1_sd, xmin=Axis1-Axis1_sd))+ggtitle("Native Species")) + facet_wrap(~River)
setwd("~/GitHub/Species-Traits")
library(tidyverse)
library(fitode)
source("transfer_functions.R")
dat <- read.csv("Algae_Nutrient.csv")
dat_nit_27 <- dat %>%
filter(treat == 27)
dat_nit_9 <- dat %>%
filter(treat == 9)
dat_nit_3 <- dat %>%
filter(treat == 3)
dat_nit_108 <- dat %>%
filter(treat == 108)
dat_nit_54 <- dat %>%
filter(treat == 54)
dat_nit_0.5 <- dat %>%
filter(treat == 0.5)
chl_nh4_mod <- new("model.ode",
name = "algal_nit",
model = list(
pred_nh4 ~ -pred_chl*((v*pred_nh4)/(pred_nh4+s))-cnitrate -cammonium,
## chl is gained through uptake of nh4 and lost through density dependent death
## death is not directly measured-- for evidence of dd death see nls feeding
pred_chl ~ pred_chl*((j*pred_nh4)/(pred_nh4+h))-pred_chl*((death*pred_chl)/(d1+pred_chl))
),
## consider using bbmle::dnorm_n ?
observation = list(
nh4 ~ dnorm(mean = pred_nh4, sd=sd1),
chl ~ dnorm(mean = pred_chl, sd=sd2)
),
initial = list(pred_nh4 ~ pred_nh40 , pred_chl ~ pred_chl0),
par=c("v","s","j","h","pred_nh40","pred_chl0", "sd1","sd2", "death","d1")
)
# options(error=recover)  ## stop/browse when error occurs
chl_fit_27_dd <- fitode(
chl_nh4_mod,
data = dat_nit_27,
start=c(v = 45,
s = 3500,
j = 150,
h = 5000,
pred_nh40 = 15 ,
pred_chl0 = 15,
sd1 = 3 ,
sd2 = 3,
death=0.00001,
d1=1),
tcol = "date1" #,
#method="Nelder-Mead"
)
# options(error=recover)  ## stop/browse when error occurs
chl_fit_27_dd <- fitode(
chl_nh4_mod,
data = dat_nit_27,
start=c(v = 45,
s = 3500,
j = 150,
h = 5000,
pred_nh40 = 15 ,
pred_chl0 = 15,
sd1 = 3 ,
sd2 = 3,
death=0.1,
d1=1),
tcol = "date1" #,
#method="Nelder-Mead"
)
# options(error=recover)  ## stop/browse when error occurs
chl_fit_27_dd <- fitode(
chl_nh4_mod,
data = dat_nit_27,
start=c(v = 10,
s = 10,
j = 10,
h = 100,
pred_nh40 = 15 ,
pred_chl0 = 15,
sd1 = 1 ,
sd2 = 1,
death=0.1,
d1=1),
tcol = "date1" #,
#method="Nelder-Mead"
)
# options(error=recover)  ## stop/browse when error occurs
chl_fit_27_dd <- fitode(
chl_nh4_mod,
data = dat_nit_27,
start=c(v = 1,
s = 1,
j = 1,
h = 1,
pred_nh40 = 15 ,
pred_chl0 = 15,
sd1 = 1 ,
sd2 = 1,
death=0.1,
d1=1),
tcol = "date1" #,
#method="Nelder-Mead"
)
options(error=recover)  ## stop/browse when error occurs
chl_fit_27_dd <- fitode(
chl_nh4_mod,
data = dat_nit_27,
start=c(v = 1,
s = 1,
j = 1,
h = 1,
pred_nh40 = 15 ,
pred_chl0 = 15,
sd1 = 1 ,
sd2 = 1,
death=0.1,
d1=1),
tcol = "date1" #,
#method="Nelder-Mead"
)
chl_fit_27_dd <- fitode(
chl_nh4_mod,
data = dat_nit_27,
start=c(v = 10,
s = .1,
j = 1,
h = 1,
pred_nh40 = 15 ,
pred_chl0 = 15,
sd1 = 1 ,
sd2 = 1,
death=0.1,
d1=1),
tcol = "date1" #,
#method="Nelder-Mead"
)
chl_fit_27_dd <- fitode(
chl_nh4_mod,
data = dat_nit_27,
start=c(v = 10,
s = .1,
j = 1,
h = 10,
pred_nh40 = 15 ,
pred_chl0 = 15,
sd1 = 1 ,
sd2 = 1,
death=0.1,
d1=1),
tcol = "date1" #,
#method="Nelder-Mead"
)
chl_fit_27_dd <- fitode(
chl_nh4_mod,
data = dat_nit_27,
start=c(v = 10,
s = .1,
j = .1,
h = 10,
pred_nh40 = 15 ,
pred_chl0 = 15,
sd1 = 1 ,
sd2 = 1,
death=0.1,
d1=1),
tcol = "date1" #,
#method="Nelder-Mead"
)
chl_fit_27_dd <- fitode(
chl_nh4_mod,
data = dat_nit_27,
start=c(v = 10,
s = .1,
j = .1,
h = 100,
pred_nh40 = 15 ,
pred_chl0 = 15,
sd1 = 1 ,
sd2 = 1,
death=0.01,
d1=1),
tcol = "date1" #,
#method="Nelder-Mead"
)
