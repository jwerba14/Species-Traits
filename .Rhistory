install.packages("R2jags")
install.packages("tidyr")
install.packages("lme4")
install.packages("tidyverse")
install.packages("ggplot2")
library(readxl)
library(tidyverse)
library(ggplot2)
dat <- read_excel("~/Preliminary Data/Data_sheet_FeedingExpt.xlsx")
cleandat <- dat %>%
group_by(Treatment) %>%
summarize_all(funs(mean,sd))
cleandat <- dat %>%
group_by(Treatment) %>%
summarize_all(funs(mean,sd), na.rm=TRUE)
warnings()
View(cleandat)
cleandat<- cleandat[,c(1,5,7,11,13,21,23,27,29)]
View(cleandat)
cdat1 <- cleandat[,c(2,3,6,7)]
cdat2 <- cleandat[,c(4,5,8,9)]
bind_rows(cdat1,cdat2)
rownames(cdat1) <- c("chl_mean", "Nh4_mean", "chl_SD", "Nh4_SD")
?rownames
cdat1 <- data.frame(cleandat[,c(2,3,6,7)])
rownames(cdat1) <- c("chl_mean", "Nh4_mean", "chl_SD", "Nh4_SD")
colnames(cdat1) <- c("chl_mean", "Nh4_mean", "chl_SD", "Nh4_SD")
colnames(cdat2) <- c("chl_mean", "Nh4_mean", "chl_SD", "Nh4_SD")
newdat <- bind_rows(cdat1,cdat2)
newdat
newdat$time <- rep(1:2, each=5)
newdat
newdat$treat <- rep(1:5,2)
newdat
library(ggplot2)
ggplot(newdat, aes(time,chl_mean))+geom_point(aes(color=treat))
newdat$treat <- as.factor(rep(1:5,2))
ggplot(newdat, aes(time,chl_mean))+geom_point(aes(color=treat))
?geom_errorbar
ggplot(newdat, aes(time,chl_mean))+geom_point(aes(color=treat))+
geom_errorbar(aes(ymin=chl_mean-chl_SD, ymax=chl_mean+chl_SD)
)
ggplot(newdat, aes(time,Nh4_mean))+geom_point(aes(color=treat))+
geom_errorbar(aes(ymin=Nh4_mean-Nh4_SD, ymax=Nh4_mean+Nh4_SD)
ggplot(newdat, aes(time,Nh4_mean))+geom_point(aes(color=treat))+
geom_errorbar(aes(ymin=Nh4_mean-Nh4_SD, ymax=Nh4_mean+Nh4_SD)
ggplot(newdat, aes(time,Nh4_mean))+geom_point(aes(color=treat))+
geom_errorbar(aes(ymin=Nh4_mean-Nh4_SD, ymax=Nh4_mean+Nh4_SD))
View(newdat)
ggplot(newdat, aes(time,Nh4_mean))+geom_point(aes(color=treat))
ggplot(newdat, aes(time,Nh4_mean))+geom_point(aes(color=treat))+
geom_errorbar(aes(ymin=Nh4_mean-Nh4_SD, ymax=Nh4_mean+Nh4_SD))
ggplot(newdat, aes(time,Nh4_mean))+geom_point(aes(color=treat))+
geom_errorbar(aes(ymin=Nh4_mean-Nh4_SD, ymax=Nh4_mean+Nh4_SD))
newdat
131.6 / 2.2
131.6 * 2.2
131.6 * 2
131.6 * 2 / 2.2
new_dat1 <- new_dat[new_dat$time == "1", ]
newdat1 <- newdat[newdat$time == "1", ]
newdat2 <- newdat[newdat$time == "2", ]
new_dat <- rbind(newdat1, newdat2$chl_mean)
new_dat <- rbind(newdat1, data.frame(newdat2$chl_mean))
new_dat <- cbind(newdat1, data.frame(newdat2$chl_mean))
new_dat <- cbind(newdat1, data.frame(chl_mean_end = newdat2$chl_mean))
ggplot(newdat, aes(time, chl_mean_end / chl_mean))+geom_point(aes(color=treat))+
geom_errorbar(aes(ymin=chl_mean-chl_SD, ymax=chl_mean+chl_SD))
ggplot(newdat, aes(time, chl_mean))+geom_point(aes(color=treat))+
geom_errorbar(aes(ymin=chl_mean-chl_SD, ymax=chl_mean+chl_SD))
ggplot(new_dat, aes(time, chl_mean_end / chl_mean))+geom_point(aes(color=treat))
new_dat
ggplot(new_dat, aes(chl_mean, chl_mean_end / chl_mean))+geom_point(aes(color=treat))
ggplot(new_dat, aes(chl_mean, chl_mean_end / chl_mean))+geom_point(lwd = 5)
cleandat
head(dat)
ggplot(dat, aes(Treatment, 'Chl 2' / 'Chl 1'))+geom_point(lwd = 5)
names(dat)
ggplot(dat, aes(Treatment, 'Chl 2' / 'Chl 1'))+geom_point(lwd = 2)
names(dat); str(dat)
death2 <- function(a,b, chl){
a^b*chl
}
par(mfrow = c(1,1));plot(death2(0.25, 10, seq(40, 200, by = 10)))
death2 <- function(a,b, chl){
a*chl^b
}
par(mfrow = c(1,1));plot(death2(2, 3, seq(40, 200, by = 10)))
death <- function(a,b,chl){
a*chl^(1/b)
}
par(mfrow = c(1,1));plot(death(0.25, 10, seq(40, 200, by = 10)))
fun <- function (dat,a, s,z, sd_chl_proc, sd_nh4_proc, sd_chl_obs, sd_nh4_obs) {
for (i in 1:length(unique(faux$ind))) {  #to follow an individual replicate
for (j in 2:length(unique(faux$time))) { #over each time point
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$nh4 <-
z *  subset(faux, ind == unique(faux$ind)[i] & time == unique(faux$time)[j-1])$nh4
#process level in z (nh4)
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$nh4 <-
rlnorm(1,log(faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$nh4),
log(sd_nh4_proc))
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$chl <-
# yesterdays chl +
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j-1], ]$chl+
# a times yesterday nh4/(s +yesterday Nh4)*
((a*faux[faux$ind==unique(faux$ind)[i]&faux$time==unique(faux$time)[j-1],]$nh4)/
(s+faux[faux$ind==unique(faux$ind)[i]&faux$time==unique(faux$time)[j-1],]$nh4)*
# yesterdays chl-
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j-1], ]$chl) -
#(D * yesterdays chl)* yesterdays chl so that D is density dependent
death2(2,3, faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j-1], ]$chl)*
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j-1], ]$chl
#process level in chl
faux[faux$ind==unique(faux$ind)[i] & faux$time==unique(faux$time)[j], ]$chl <-
rlnorm(1,log(faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$chl),
log(sd_chl_proc))
}
}
#observation level error
faux$chl<- rlnorm(length(faux$chl),log(faux$chl),log(sd_chl_obs))
faux$nh4 <- rlnorm(length(faux$nh4), log(faux$nh4),log(sd_nh4_obs))
return(list(c(a=a,s=s,z=z,sd_chl_proc=sd_chl_proc, sd_nh4_proc=sd_nh4_proc,
sd_chl_obs=sd_chl_obs, sd_nh4_obs=sd_nh4_obs), faux))
}
faux_out[c(1,2)] <- fun(dat=faux,a=1,s=20,z=0.9,sd_chl_proc=1.0, sd_nh4_proc=1.0,
sd_chl_obs=1.0, sd_nh4_obs=1.0)
faux <- data.frame(
time = rep(seq(1,27),each=25),
ind = rep(seq(1,25), 27),
chl = c(rep(40,25),rep(0,650)),
nh4 = c(rep(c(3,9,18,36,54),each =5),rep(0,650)))
faux_out <- vector("list", 16)
faux_out[c(1,2)] <- fun(dat=faux,a=1,s=20,z=0.9,sd_chl_proc=1.0, sd_nh4_proc=1.0,
sd_chl_obs=1.0, sd_nh4_obs=1.0)
par(mfrow = c(1,1));plot(death2(1, 2, seq(40, 200, by = 10)))
par(mfrow = c(1,1));plot(death2(0.2, 2, seq(40, 200, by = 10)))
faux_out[c(1,2)] <- fun(dat=faux,a=1,s=20,z=0.9,sd_chl_proc=1.0, sd_nh4_proc=1.0,
sd_chl_obs=1.0, sd_nh4_obs=1.0)
fun <- function (dat,a, s,z, sd_chl_proc, sd_nh4_proc, sd_chl_obs, sd_nh4_obs) {
for (i in 1:length(unique(faux$ind))) {  #to follow an individual replicate
for (j in 2:length(unique(faux$time))) { #over each time point
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$nh4 <-
z *  subset(faux, ind == unique(faux$ind)[i] & time == unique(faux$time)[j-1])$nh4
#process level in z (nh4)
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$nh4 <-
rlnorm(1,log(faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$nh4),
log(sd_nh4_proc))
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$chl <-
# yesterdays chl +
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j-1], ]$chl+
# a times yesterday nh4/(s +yesterday Nh4)*
((a*faux[faux$ind==unique(faux$ind)[i]&faux$time==unique(faux$time)[j-1],]$nh4)/
(s+faux[faux$ind==unique(faux$ind)[i]&faux$time==unique(faux$time)[j-1],]$nh4)*
# yesterdays chl-
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j-1], ]$chl) -
#(D * yesterdays chl)* yesterdays chl so that D is density dependent
death2(0.02,2, faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j-1], ]$chl)*
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j-1], ]$chl
#process level in chl
faux[faux$ind==unique(faux$ind)[i] & faux$time==unique(faux$time)[j], ]$chl <-
rlnorm(1,log(faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$chl),
log(sd_chl_proc))
}
}
#observation level error
faux$chl<- rlnorm(length(faux$chl),log(faux$chl),log(sd_chl_obs))
faux$nh4 <- rlnorm(length(faux$nh4), log(faux$nh4),log(sd_nh4_obs))
return(list(c(a=a,s=s,z=z,sd_chl_proc=sd_chl_proc, sd_nh4_proc=sd_nh4_proc,
sd_chl_obs=sd_chl_obs, sd_nh4_obs=sd_nh4_obs), faux))
}
faux_out[c(1,2)] <- fun(dat=faux,a=1,s=20,z=0.9,sd_chl_proc=1.0, sd_nh4_proc=1.0,
sd_chl_obs=1.0, sd_nh4_obs=1.0)
par(mfrow = c(2, 1)); with(faux_out[[2]], plot(time, nh4)); with(faux_out[[2]], plot(time, log(chl)))
fun <- function (dat,a, s,z, sd_chl_proc, sd_nh4_proc, sd_chl_obs, sd_nh4_obs) {
for (i in 1:length(unique(faux$ind))) {  #to follow an individual replicate
for (j in 2:length(unique(faux$time))) { #over each time point
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$nh4 <-
z *  subset(faux, ind == unique(faux$ind)[i] & time == unique(faux$time)[j-1])$nh4
#process level in z (nh4)
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$nh4 <-
rlnorm(1,log(faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$nh4),
log(sd_nh4_proc))
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$chl <-
# yesterdays chl +
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j-1], ]$chl+
# a times yesterday nh4/(s +yesterday Nh4)*
((a*faux[faux$ind==unique(faux$ind)[i]&faux$time==unique(faux$time)[j-1],]$nh4)/
(s+faux[faux$ind==unique(faux$ind)[i]&faux$time==unique(faux$time)[j-1],]$nh4)*
# yesterdays chl-
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j-1], ]$chl) -
#(D * yesterdays chl)* yesterdays chl so that D is density dependent
death2(0.002,2, faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j-1], ]$chl)*
faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j-1], ]$chl
#process level in chl
faux[faux$ind==unique(faux$ind)[i] & faux$time==unique(faux$time)[j], ]$chl <-
rlnorm(1,log(faux[faux$ind == unique(faux$ind)[i] & faux$time == unique(faux$time)[j], ]$chl),
log(sd_chl_proc))
}
}
#observation level error
faux$chl<- rlnorm(length(faux$chl),log(faux$chl),log(sd_chl_obs))
faux$nh4 <- rlnorm(length(faux$nh4), log(faux$nh4),log(sd_nh4_obs))
return(list(c(a=a,s=s,z=z,sd_chl_proc=sd_chl_proc, sd_nh4_proc=sd_nh4_proc,
sd_chl_obs=sd_chl_obs, sd_nh4_obs=sd_nh4_obs), faux))
}
faux_out[c(1,2)] <- fun(dat=faux,a=1,s=20,z=0.9,sd_chl_proc=1.0, sd_nh4_proc=1.0,
sd_chl_obs=1.0, sd_nh4_obs=1.0)
par(mfrow = c(2, 1)); with(faux_out[[2]], plot(time, nh4)); with(faux_out[[2]], plot(time, log(chl)))
faux_out[c(1,2)] <- fun(dat=faux,a=3,s=20,z=0.9,sd_chl_proc=1.0, sd_nh4_proc=1.0,
sd_chl_obs=1.0, sd_nh4_obs=1.0)
par(mfrow = c(2, 1)); with(faux_out[[2]], plot(time, nh4)); with(faux_out[[2]], plot(time, log(chl)))
warnings()
load("C:/Users/jower/Downloads/msfinal.Rdata")
View(adata2)
View(bigdata2)
unique(bigdata$Dispersal)
library(tidyverse)
?n_distinct
#first vector is saying rmax(parameter) start at 0.01 and then environ variable- need 3rd for pop but pop is extinct because PopZe
output <- PSPMequi("StageStructuredTemplate.R", 'EQ', c(3,3), -0.1, c(1,0.01,10), NULL,
c('popZE', '0'))
library(PSPManalysis)
library(devtools)
#first vector is saying rmax(parameter) start at 0.01 and then environ variable- need 3rd for pop but pop is extinct because PopZe
output <- PSPMequi("StageStructuredTemplate.R", 'EQ', c(3,3), -0.1, c(1,0.01,10), NULL,
c('popZE', '0'))
setwd("C:/Users/jower/OneDrive/PSPM")
#dynamics over time (wed morning)
library(PSPManalysis)
library(devtools)
library(ggplot2)
setwd("C:/Users/jower/OneDrive/PSPM")
Bif = PSPMequi("KM_Roach.h", "EQ", c(0.7,8.743305e-06, 2.806768e-06 ), 0.1,c(11,0.4,0.999), NULL, c("popEVO", "0"))
Canonical <- PSPMevodyn("KM_Roach",c(8.743305e-06, 2.806768e-06,0.7), c(10,3000), c(11,0,1), NULL, NULL, c("popEVO", "0"))
g<- data.frame(Canonical$curvepoints)
Canonical
#V1 is evol time V4 is Kappa
ggplot(g, aes(V1,V4)) + geom_point()
#V1 is evol time V4 is Kappa
ggplot(g, aes(V1,V4)) + geom_point()+ylab("Kappa")+xlab("Time")
Bif$bifpoints
Bif
PIP=PSPMequi("KM_Roach.h", "PIP", c(0.9672899 5.785926e-06 3.444434e-06),
0.1, c(11,0.4,0.999), NULL, c("popEVO", "1") , clean = FALSE)
PIP=PSPMequi("KM_Roach.h", "PIP", c(0.9672899 5.785926e-06 3.444434e-06),
0.1, c(11,0.4,0.999), NULL, c("popEVO","1"), clean = FALSE)
Bif$biftypes
Bif$bifpoints
Bif
PIP <- PSPMequi("KM_Roach.h","PIP" c(0.9672899, 5.785926e-06, 3.444434e-06,0.9672899),0.1,
c(11,0.4,1,11,0.4,1),NULL, c("popEVO", "0"))
PIP <- PSPMequi("KM_Roach.h","PIP", c(0.9672899, 5.785926e-06, 3.444434e-06,0.9672899),0.1,
c(11,0.4,1,11,0.4,1),NULL, c("popEVO", "0"))
PIP <- PSPMequi("KM_Roach.h","PIP", c(0.9672899, 5.785926e-06, 3.444434e-06,0.9672899),-0.1,
c(11,0.4,1,11,0.4,1),NULL, c("popEVO", "0"))
PIP <- PSPMequi("KM_Roach.h","PIP", c(0.9672899, 5.785926e-06, 3.444434e-06,0.9672899),0.1,
c(11,0.4,1,11,0.4,1),NULL, c("popEVO", "0"))
PIP_1 <- PSPMequi("KM_Roach.h","PIP", c(0.9672899, 5.785926e-06, 3.444434e-06,0.9672899),-0.1,
c(11,0.4,1,11,0.4,1),NULL, c("popEVO", "0"))
PIP
#V1 =kappa res V4 = kappy mutant
pip_pos <- data.frame(PIP$curvepoints)
ggplot(pip_pos, aes(V1,V4))+geom_point()
pip_neg <- data.frame(PIP_1$curvepoints)
ggplot(pip_pos, aes(V1,V4))+geom_point()+geom_point(data = pip_neg,aes(V1,V4, color="red"))
setwd("~/GitHub/PreliminaryExperiments")
# attempt to write system of differential equations
source("transfer_functions.r")
library(deSolve)
state <- c(ammonium = 5,
nitrate = 5,
daph_j = 10,
daph_a = 10,
cerio = 20,
algae = 50
)
#parameters- will need parameters for each function
parameters <- c(
a = 0.1,b = 0.1,  # daphnia adult release Nh4
c= 0.01, d = 0.01, # daphnia juv release Nh4
e = 0.001, f =0.001, #cerio release Nh4
dj =0.000001 , drj = 0.000001, # daphnia juv death
dm = 0.00001, drm = 0.00001, # daphnia adult death
dc = 0.00001, drc = 0.0001, # cerio death
da = 0.001, dra = 0.001, # algae death
t = 0.01, h = 0.01, # mich men uptake nh4
cammonium = .000001, # ammonium lost to env
n = .0001, # nitrification constant
p= .001, q = .001, # mich men uptake nitrate
cnitrate = .000001, # nitrate lost to env
z =0.001, w = 0.0001, # birth of juvenile daphnia
l =.000026, m= -448,  # uptake of algae by juvenile hollings type II
g = 0.0001, i= 0.001, # birth of cerio
j = 0.0000939, k= 10.7, # uptake of algae by adult daphnia hollings type II
y= .0000001, r = -500 # uptake of algae by cerio hollings type II (prob need to change to linear)
)
full_equations <-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
# ammonium is added from release by all 3 zoo species (each times a constant?)
dammonium <- daph_a*sat_fun(a,b,algae) + daph_j*sat_fun(c,d,algae)+
cerio*sat_fun(e,f,algae)*y +
# also add a constant released based on density dependent death
daph_j*death(dj,daph_j)*drj + daph_a*death(dm,daph_a)*drm + cerio*death(dc,cerio)*drc -
algae*death(da,algae)*dra-
# lose from uptake and a density dependent (?) from air
algae*mich_men(t,h,ammonium) - cammonium*ammonium
# nitrate is added by nitrification from ammonium at a constant rate
dnitrate <- n*ammonium -
# nitrate is loss to air at a density dependent rate and from uptake by algae
algae*mich_men(p,q, nitrate) - cnitrate*nitrate
#juvenile daphia are added by density dependent (large daphnia) birth
ddaph_j <- sat_fun(z,w,algae)*daph_a -
#loss through death and growth -where they reach a certain threshold size --- don't know how to put that in
daph_j*death(dj,daph_j) - sat_fun(l,m,algae)*daph_j
#daphnia adults are added from growth by juveniles and are lost from death
ddaph_a <- sat_fun(l,m,algae)*daph_j- daph_a*death(dm,daph_a)
#ceriodaphnia are added by birth and are lost from death
dcerio <- sat_fun(g,i,algae)*cerio - cerio*death(dc, cerio)
# algae is added from growth based on uptake of ammonium and nitrate #need to add contanst to mm
dalgae <- algae*mich_men(t,h,ammonium) + algae*mich_men(p,q, nitrate) -
# algae is lost from being eaten by each of the 3 zooplankon
-daph_a*hollings2(j,k,algae) + daph_j*hollings2(l,m,algae)+cerio*hollings2(y,r,algae) -
# density dependent death
algae*death(da,algae)
# return the rate of change
list(c(dammonium, dnitrate, ddaph_j,ddaph_a,dcerio,dalgae))
}) # end with(as.list ...
}
out <- ode(y = state, times = seq(0,100,0.1), func = full_equations, parms = parameters)
plot(out)
